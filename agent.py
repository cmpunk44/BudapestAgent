{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "371241d9-5f51-4277-b335-a4811135214b",
   "metadata": {},
   "outputs": [],
   "source": [
    "from dotenv import load_dotenv\n",
    "load_dotenv()\n",
    "\n",
    "import os\n",
    "import json\n",
    "import re\n",
    "import requests\n",
    "import operator\n",
    "from typing import TypedDict, Annotated\n",
    "\n",
    "from langchain.schema import HumanMessage, SystemMessage\n",
    "from langchain_core.messages import ToolMessage, AnyMessage\n",
    "from langchain_openai import ChatOpenAI\n",
    "from langgraph.graph import StateGraph, END\n",
    "from langchain_core.tools import tool\n",
    "\n",
    "# === 1. API kulcsok betöltése ===\n",
    "OPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n",
    "MAPS_API_KEY = os.getenv(\"MAPS_API_KEY\")\n",
    "\n",
    "# === 2. LLM példány ===\n",
    "llm = ChatOpenAI(model=\"gpt-4o-mini\", openai_api_key=OPENAI_API_KEY, temperature=0.3)\n",
    "\n",
    "# === 3. Tool: helyszínek kinyerése szövegből ===\n",
    "def parse_trip_input(user_input: str) -> dict:\n",
    "    prompt = f\"\"\"\n",
    "    You are a multilingual assistant. Extract two locations from this sentence.\n",
    "    Respond ONLY with a JSON like:\n",
    "    {{\"from\": \"X\", \"to\": \"Y\"}}\n",
    "    Input: \"{user_input}\"\n",
    "    \"\"\"\n",
    "    messages = [HumanMessage(content=prompt)]\n",
    "    response = llm.invoke(messages)\n",
    "\n",
    "    try:\n",
    "        return json.loads(response.content)\n",
    "    except:\n",
    "        match = re.search(r'from\\s+(.*?)\\s+to\\s+(.*)', user_input, re.IGNORECASE)\n",
    "        return {\"from\": match.group(1), \"to\": match.group(2)} if match else {\"from\": \"\", \"to\": \"\"}\n",
    "\n",
    "# === 4. Tool: Directions API ===\n",
    "def get_directions(from_place: str, to_place: str) -> dict:\n",
    "    url = \"https://maps.googleapis.com/maps/api/directions/json\"\n",
    "    params = {\n",
    "        \"origin\": from_place,\n",
    "        \"destination\": to_place,\n",
    "        \"mode\": \"transit\",\n",
    "        \"transit_mode\": \"bus|subway|train|tram\",\n",
    "        \"key\": MAPS_API_KEY\n",
    "    }\n",
    "    response = requests.get(url, params=params)\n",
    "    return response.json() if response.status_code == 200 else {\"error\": \"Directions API failed\"}\n",
    "\n",
    "# === 5. Tool: Places API ===\n",
    "def get_local_attractions(start_lat: float, start_lng: float, end_lat: float, end_lng: float) -> dict:\n",
    "    places_url = \"https://maps.googleapis.com/maps/api/place/nearbysearch/json\"\n",
    "    attractions = []\n",
    "    for lat, lng in [(start_lat, start_lng), (end_lat, end_lng)]:\n",
    "        params = {\n",
    "            \"location\": f\"{lat},{lng}\",\n",
    "            \"radius\": 1000,\n",
    "            \"type\": \"tourist_attraction\",\n",
    "            \"key\": MAPS_API_KEY\n",
    "        }\n",
    "        res = requests.get(places_url, params=params)\n",
    "        if res.status_code == 200:\n",
    "            data = res.json()\n",
    "            attractions += [r.get(\"name\") for r in data.get(\"results\", [])]\n",
    "    return {\"attractions\": attractions}\n",
    "\n",
    "# === 6. Tool dekorátorok ===\n",
    "@tool\n",
    "def parse_input_tool(text: str) -> dict:\n",
    "    \"\"\"Parses user input and extracts 'from' and 'to' destinations.\"\"\"\n",
    "    return parse_trip_input(text)\n",
    "\n",
    "@tool\n",
    "def directions_tool(from_place: str, to_place: str) -> dict:\n",
    "    \"\"\"Gets public transport route using Google Directions API.\"\"\"\n",
    "    return get_directions(from_place, to_place)\n",
    "\n",
    "@tool\n",
    "def attractions_tool(start_lat: float, start_lng: float, end_lat: float, end_lng: float) -> dict:\n",
    "    \"\"\"Finds tourist attractions near the route using Google Places API.\"\"\"\n",
    "    return get_local_attractions(start_lat, start_lng, end_lat, end_lng)\n",
    "\n",
    "# === 7. AgentState ===\n",
    "class AgentState(TypedDict):\n",
    "    messages: Annotated[list[AnyMessage], operator.add]\n",
    "\n",
    "# === 8. Agent osztály ===\n",
    "class Agent:\n",
    "    def __init__(self, model, tools, system=\"\"):\n",
    "        self.system = system\n",
    "        self.model = model.bind_tools(tools)\n",
    "        self.tools = {t.name: t for t in tools}\n",
    "\n",
    "        graph = StateGraph(AgentState)\n",
    "        graph.add_node(\"llm\", self.call_openai)\n",
    "        graph.add_node(\"action\", self.take_action)\n",
    "        graph.add_conditional_edges(\"llm\", self.exists_action, {True: \"action\", False: END})\n",
    "        graph.add_edge(\"action\", \"llm\")\n",
    "        graph.set_entry_point(\"llm\")\n",
    "        self.graph = graph.compile()\n",
    "\n",
    "    def exists_action(self, state: AgentState):\n",
    "        result = state['messages'][-1]\n",
    "        return len(result.tool_calls) > 0\n",
    "\n",
    "    def call_openai(self, state: AgentState):\n",
    "        messages = state['messages']\n",
    "        if self.system:\n",
    "            messages = [SystemMessage(content=self.system)] + messages\n",
    "        message = self.model.invoke(messages)\n",
    "        return {'messages': [message]}\n",
    "\n",
    "    def take_action(self, state: AgentState):\n",
    "        tool_calls = state['messages'][-1].tool_calls\n",
    "        results = []\n",
    "        for t in tool_calls:\n",
    "            if t['name'] not in self.tools:\n",
    "                result = \"Invalid tool name. Retry.\"\n",
    "            else:\n",
    "                result = self.tools[t['name']].invoke(t['args'])\n",
    "            results.append(ToolMessage(tool_call_id=t['id'], name=t['name'], content=str(result)))\n",
    "        return {'messages': results}\n",
    "\n",
    "# === 9. Agent példány ===\n",
    "prompt = \"\"\"\n",
    "You are a helpful assistant for Budapest public transport and sightseeing.\n",
    "You can:\n",
    "- Parse origin and destination from user input\n",
    "- Call directions_tool with both locations to get route\n",
    "- Call attractions_tool with coordinates extracted from route_data (start and end lat/lng)\n",
    "\n",
    "Call tools explicitly with correct arguments. Use multiple tools if needed.\n",
    "\"\"\"\n",
    "\n",
    "model = ChatOpenAI(model=\"gpt-4o-mini\", openai_api_key=OPENAI_API_KEY)\n",
    "tools = [parse_input_tool, directions_tool, attractions_tool]\n",
    "budapest_agent = Agent(model, tools, system=prompt)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
